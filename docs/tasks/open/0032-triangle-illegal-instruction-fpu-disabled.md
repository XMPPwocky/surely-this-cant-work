# 0032: Triangle app crashes with illegal instruction (FPU disabled for user processes)

**Reported:** 2026-02-26
**Status:** Open
**Severity:** MEDIUM
**Subsystem:** arch/trap, task/context

## Symptoms

Running `/bin/triangle` with GPU enabled crashes immediately after window creation:

```
[triangle] starting
[triangle] window ready (400x300, stride=400)
Illegal instruction at sepc=0x1aae2, stval=0xd006f7d3, SPP=0 (U-mode)
  Killing user process PID 19 due to illegal instruction
```

The `stval=0xd006f7d3` decodes as `FCVT.W.S` (convert f32 to i32) — a standard
RISC-V single-precision floating-point instruction.

## Reproduction Steps

1. Boot with GPU: use MCP server with `qemu_boot(gpu=true)` or `make run-gui`
2. At the shell, run: `run /bin/triangle`
3. Observe: illegal instruction crash after "window ready" message

100% reproducible. Any user-space code that executes an f32/f64 instruction
will trigger this.

## Investigation

### Instruction decode

`stval=0xd006f7d3` in little-endian:
- Opcode `0x53` = FP arithmetic
- funct7 `1101000` + funct3 `111` = `FCVT.W.S` (float-to-int conversion)

This is generated by Rust's `as i32` cast on an `f32` value.

### Target architecture

User-space compiles for `riscv64gc-unknown-rvos`. The `gc` = `imafd+c`, which
includes F (single-float) and D (double-float) extensions. The compiler freely
emits hardware FP instructions.

### sstatus.FS field

In `kernel/src/task/context.rs:62`, `TrapContext::new_user()` sets:
```rust
let sstatus = csr::SSTATUS_SPIE | csr::SSTATUS_SUM;
```

This leaves `sstatus.FS = 0b00` (Off). Per the RISC-V privileged spec,
FS=Off means **any floating-point instruction traps as illegal instruction**.

### FPU context save/restore

The kernel does not save or restore floating-point registers (f0-f31) anywhere:
- `trap.S` only saves/restores 32 GPRs (x0-x31)
- `switch.S` only saves/restores callee-saved GPRs (s0-s11, ra, sp)
- No `TrapFrame` fields for FP registers
- No `SSTATUS_FS` constant defined in `csr.rs`

## Root Cause

**sstatus.FS = 0 (Off)** for all user processes. The RISC-V spec requires
FS >= 1 for FP instructions to execute without trapping. The kernel never
sets this field.

**Bug class:** Missing feature / configuration error — the kernel targets
riscv64gc but doesn't enable the FPU for user-space.

**Code location:** `kernel/src/task/context.rs:62` — `new_user()` sstatus init.

## Fix (Proposed)

A complete fix requires three changes:

### 1. Enable FPU in sstatus (minimal, enables FP)

In `kernel/src/arch/csr.rs`, add:
```rust
pub const SSTATUS_FS_INITIAL: usize = 1 << 13;  // FS=01 (Initial)
```

In `kernel/src/task/context.rs:62`, update:
```rust
let sstatus = csr::SSTATUS_SPIE | csr::SSTATUS_SUM | csr::SSTATUS_FS_INITIAL;
```

### 2. Save/restore FP registers on trap entry/exit

Expand `TrapFrame` to include 32 FP registers (f0-f31, each 8 bytes for
double-precision = 256 bytes). Update `trap.S` to `fsd`/`fld` all 32 FP
registers. Update all hardcoded offsets in `trap.S` and the compile-time
assertions in `context.rs`.

### 3. Save/restore FP registers on context switch

Update `switch.S` to save/restore callee-saved FP registers (fs0-fs11)
alongside the callee-saved GPRs. Update `TaskContext` accordingly.

### Alternative: lazy FP context switching

Instead of always saving/restoring FP regs, use FS=Off by default and trap
on first FP use to lazily enable FP and allocate FP context. This is more
complex but avoids the cost of saving 32 FP registers for processes that
don't use them (most kernel tasks, many user processes).

## Affected code

Places that use f32/f64 and would crash:
- `lib/rvos-gfx/src/shapes.rs:48-59` — `fill_triangle()` scanline rasterization
- `lib/rvos-wire/src/lib.rs` — `write_f32`/`read_f32`/`write_f64`/`read_f64`
  (currently only in `#[cfg(test)]`, but available for use)

## Workaround

Replace f32 arithmetic in `fill_triangle()` with fixed-point integer math.
This avoids FP instructions entirely and works without kernel changes.

## Verification

(To be filled in when fixed)

## Lessons Learned

(To be filled in when fixed)
