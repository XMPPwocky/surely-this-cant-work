# 0032: Triangle app crashes with illegal instruction (FPU disabled for user processes)

**Reported:** 2026-02-26
**Status:** Closed (2026-02-26)
**Severity:** MEDIUM
**Subsystem:** arch/trap, arch/switch, task/context

## Symptoms

Running `/bin/triangle` with GPU enabled crashes immediately after window creation:

```
[triangle] starting
[triangle] window ready (400x300, stride=400)
Illegal instruction at sepc=0x1aae2, stval=0xd006f7d3, SPP=0 (U-mode)
  Killing user process PID 19 due to illegal instruction
```

The `stval=0xd006f7d3` decodes as `FCVT.W.S` (convert f32 to i32) — a standard
RISC-V single-precision floating-point instruction.

## Reproduction Steps

1. Boot with GPU: use MCP server with `qemu_boot(gpu=true)` or `make run-gui`
2. At the shell, run: `run /bin/triangle`
3. Observe: illegal instruction crash after "window ready" message

100% reproducible. Any user-space code that executes an f32/f64 instruction
will trigger this.

## Investigation

### Instruction decode

`stval=0xd006f7d3` in little-endian:
- Opcode `0x53` = FP arithmetic
- funct7 `1101000` + funct3 `111` = `FCVT.W.S` (float-to-int conversion)

This is generated by Rust's `as i32` cast on an `f32` value.

### Target architecture

User-space compiles for `riscv64gc-unknown-rvos`. The `gc` = `imafd+c`, which
includes F (single-float) and D (double-float) extensions. The compiler freely
emits hardware FP instructions.

### sstatus.FS field

In `kernel/src/task/context.rs:62`, `TrapContext::new_user()` sets:
```rust
let sstatus = csr::SSTATUS_SPIE | csr::SSTATUS_SUM;
```

This leaves `sstatus.FS = 0b00` (Off). Per the RISC-V privileged spec,
FS=Off means **any floating-point instruction traps as illegal instruction**.

### FPU context save/restore

The kernel did not save or restore floating-point registers (f0-f31) anywhere:
- `trap.S` only saved/restored 32 GPRs (x0-x31)
- `switch.S` only saved/restored callee-saved GPRs (s0-s11, ra, sp)
- No `TrapFrame` fields for FP registers
- No `SSTATUS_FS` constant defined in `csr.rs`

## Root Cause

**sstatus.FS = 0 (Off)** for all user processes. The RISC-V spec requires
FS >= 1 for FP instructions to execute without trapping. The kernel never
set this field.

**Bug class:** Missing feature / configuration error — the kernel targets
riscv64gc but didn't enable the FPU for user-space.

**Code location:** `kernel/src/task/context.rs:62` — `new_user()` sstatus init.

## Fix

Three changes, implementing eager FPU context saving:

### 1. Enable FPU in sstatus

Added `SSTATUS_FS_INITIAL` constant to `kernel/src/arch/csr.rs` (bits [14:13]
= 01, meaning "Initial" — FPU enabled). Set this in both `new_user()` and
`new_kernel()` so all tasks can execute FP instructions (the kernel target
is also `riscv64gc`, so it could emit FP instructions).

### 2. Save/restore all FP registers on trap entry/exit

Expanded `TrapFrame` to include `fpregs: [u64; 32]` (f0-f31) and `fcsr: usize`.
New layout:
- offset 0..255: regs[32] (GPRs)
- offset 256..511: fpregs[32] (FP regs, 32 × 8 bytes)
- offset 512: fcsr
- offset 520: sstatus
- offset 528: sepc

Updated `trap.S` to `fsd`/`fld` all 32 FP registers and `frcsr`/`fscsr` for
the fcsr CSR. Updated all hardcoded offsets (sstatus: 256→520, sepc: 264→528,
kernel_stack_top: 272→536, user_satp: 280→544). Added `.option arch, +f, +d`
directive so the LLVM integrated assembler accepts FP instructions in
`global_asm!` blocks.

### 3. Save/restore callee-saved FP registers on context switch

Expanded `TaskContext` to include `fs0..fs11: u64` (12 callee-saved FP regs)
and `fcsr: usize`. Updated `switch.S` to `fsd`/`fld` fs0-fs11 and
`frcsr`/`fscsr` alongside the existing GPR save/restore.

### Design choice: eager vs lazy

Chose eager (always save/restore) over lazy (trap-on-first-use) for simplicity.
The cost is 32 extra FSD + 32 FLD per trap and 12 extra FSD + 12 FLD per
context switch. On QEMU this is negligible. A lazy approach could be added
later as an optimization if needed.

## Verification

- `make clippy` — clean
- `make test-quick` — 69 passed, 0 failed
- `make test` — 82 passed, 0 failed (full suite including blk/spawn/http tests)
- GPU test via MCP: `triangle` renders correctly (colored triangle visible in
  window, no crash), `winclient` still works

## Lessons Learned

### Blast radius
Any user-space code using f32/f64 was affected. Currently `fill_triangle()`
in `lib/rvos-gfx/src/shapes.rs` is the main user. The wire format helpers
(`write_f32`/`read_f32`) exist but are cfg(test)-only. Future apps using
floating point will now work correctly.

### Prevention
The compile-time assertions in `context.rs` that check TrapFrame/TrapContext
offsets were invaluable — they immediately caught the layout change when FP
fields were added, preventing subtle offset mismatches between Rust and asm.

### LLVM assembler and global_asm!
`global_asm!` blocks in Rust don't automatically inherit target features from
the target triple. Even though the target is `riscv64gc` (which includes F+D),
FP instructions in `.S` files included via `global_asm!(include_str!(...))` fail
unless `.option arch, +f, +d` is explicitly set in the assembly file. This is
an important gotcha for any future assembly additions.
